#!/usr/bin/env python
# -*- coding: utf-8 -*-
# this file is an improvement examination for sugiyama algorithm

import copy
import itertools
import json
import math


def removeNode(N, n):  # remove the node: n, in N
    if N.get(n) is None:
        return

    for p in N[n]['in']:  # for parent (remove all that have this as child)
        N[p]['out'].remove(n)

    for c in N[n]['out']:  # for child (remove all that have this as parent)
        N[c]['in'].remove(n)

    del N[n]  # dictionary remove


def removeEdges(N, E):  # remove the edge: E
    for s, d in E:
        if d in N[s]['out']:
            N[s]['out'].remove(d)  # 从出点s的out列表里删除了对入点d的指向

        if s in N[d]['in']:
            N[d]['in'].remove(s)  # 同理


def insertEdges(N, E):
    for s, d in E:
        if d not in N[s]['out']:
            N[s]['out'].append(d)

        if s not in N[d]['in']:
            N[d]['in'].append(s)


def twistEdges(N, E):
    removeEdges(N, E)
    E_inv = [(d, s) for s, d in E]
    insertEdges(N, E_inv)

    return E_inv


def graphFromEdges(E):
    N = {}
    # node: in = [] out = []
    for e in E:
        s, d = e

        if N.get(s) is None:
            N[s] = {'in': [], 'out': []}

        if N.get(d) is None:
            N[d] = {'in': [], 'out': []}

        N[s]['out'].append(d)  # out
        N[d]['in'].append(s)  # in
    return N


def printGraph(N):
    for n in N:  # n只包含键值
        print(str(n))
        for e in N[n]:  # 深入访问属性
            print('{}: {}'.format(e, N[n][e]))


# if __name__ == '__main__':
#     edges = [('A', 'B'), ('A', 'E'), ('B', 'C'), ('C', 'D'), ('D', 'C'), ('A', 'C')]
#     printGraph(graphFromEdges(edges))


# 1. Eliminate cycles
# 2. Assign nodes to levels
# 3. Minimize edge crosses
# 4. Assign nodes to cartesian coordinates
# 5. Restore original cycles

# 1. Eliminate cycles, build succession with minimal count of backedge.
#   (a) Save sources and sinks in two different lists
#   (b) Remove source nodes successively and add to source list
#   (c) remove sink nodes successively and add to sink list
#   (d) chose next candidate according to in- and out-rank of node, rangOut = maxNode( [R_out(v) - R_in(v) for v in G] )
#   (e) remove v from Graph and add to source list
def cycleAnalysis(G):
    N = copy.deepcopy(G)  # graph will be altered... copy graph
    # printGraph(N)

    Sl, Sr = [], []  # Sl, Sr in Sugiyama et. al.

    while N:  # while N not empty
        sources = [n for n in N if len(N[n]['in']) == 0]  # with the attribute 'in' === 0, this must be an source node
        sinks = [n for n in N if len(N[n]['out']) == 0]  # with the attribute 'out' === 0, this must be an target node

        # this is a dynamical progress
        # we only process one node once, because no matter what we have done,
        # the effects will affect the nodes set: N immediately, and we should reconsider about that
        # (b)
        if sources:
            Sl += sources
            for n in sources:
                removeNode(N, n)  # remove all sinks

        # (c)
        elif sinks:
            Sr += sinks
            for n in sinks:
                removeNode(N, n)  # remove all sinks

        # (d)
        elif N:
            o = max(N, key=lambda n: len(N[n]['out']) - len(N[n]['in']))  # get node with maximum rangOut
            # (e)
            Sl += [o]
            removeNode(N, o)

    return Sl + Sr


# invert cyclic edge
def invertBackEdges(G, S):
    # use the sequence S that generated by cycleAnalysis to
    N = copy.deepcopy(G)  # graph will be altered... copy graph
    B = []  # backedges
    for i, n in enumerate(S):
        # enumerate() 函数可将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标
        # now i is the index and n is the data

        C = N[n]['out']  # children
        for c in C:
            j = S.index(c)
            if j < i:
                B += [(n, c)]

    twistEdges(N, B)

    return N


# 2. Assign each node to horizontal Level
#   (a) Determine sinks
#   (b) Assign them to new level
#   (c) Delete all sinks from graph

# takes acyclic Graph
def levelAssignment(G):
    N = copy.deepcopy(G)

    L = []  # levels

    while N:  # while N not empty
        # (a)
        sources = [n for n in N if len(N[n]['in']) == 0]

        # (c)
        L += [sources]  # L = []; L += [ ['A', 'B', 'C'] ] =>  L = [ ['A', 'B', 'C'] ]

        # (b)
        for n in sources:
            removeNode(N, n)

    return L  # [x for x in reversed(L)]  # reversed: reverse a sequence


# take (a, b) and if there lies a level between them (which they are not connected over):
#   - take a as from node,
#   - create a new node
#   - connect that new node to a
#   - connect that new node to b
#   - for multiple levels in between
def solveMidTransition(N, edge, L):
    (a, b) = edge

    # return the levels that lie between the node

    lfrom = N[a]['level']
    lto = N[b]['level']

    if lto < lfrom:
        step = -1
    else:
        step = 1

    removeEdges(N, [(a, b)])  # remove original edge

    u = a  # (u, v)
    for i in range(lfrom + step, lto, step):  # for levels between a and b
        # v = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(3))
        v = str("dummy" + "->" + str(a) + "->" + str(b) + "->V" + str(i))

        N[u]['out'] += [v]
        N[v] = {'in': [u], 'out': [], 'level': i, 'between': True}
        L[i] += [v]  # add to level
        u = v

    N[u]['out'] += [b]  # u is last created node... connect that one to b
    N[b]['in'] += [u]  # u is last created node... connect that one to b

    return N, L


def getInBetweenNodes(G, L):
    N = copy.deepcopy(G)

    for i, l in enumerate(L):
        for j in l:
            N[j]['level'] = i  # assign each node a level

    IB = []

    # n: current source node
    # nLevel: the rank or current source node
    # c: current target node which lies in "out" list of current source node
    # cLevel: the rank of current target node
    # when fabs(cLevel-nLevel) > 0, it means this link covers more than two ranks
    for nLevel, l in enumerate(L):
        for n in l:
            node = N[n]
            for c in node['out']:
                cLevel = N[c]['level']

                dif = math.fabs(cLevel - nLevel)  # if more than two level between
                if dif > 1:
                    IB += [(n, c)]

    for (n, c) in IB:
        solveMidTransition(N, (n, c), L)

    return N, L


def barycenterMatrixCalc(A):
    """
    Calcualate the barycenter each line and row
    :param A: the matrix
        example
        A = [
            [1, 1, 0, 0, 0],
            [1, 0, 0, 1, 1],
            [0, 1, 0, 1, 1],
            [1, 0, 1, 0, 1]
        ]
    :return: K value, BikR, BilC
    """

    BikR = [0.0 for _ in range(len(A))]
    BilC = [0.0 for _ in range(len(A[0]))]

    for i in range(len(A)):
        normalSum = 0
        weightsSum = 0
        for _ in range(len(A[i])):
            normalSum += A[i][_]
            weightsSum += (_ + 1) * A[i][_]
        if normalSum == 0:
            BikR[i] = -1.0
        else:
            BikR[i] = weightsSum / normalSum

    for i in range(len(A[0])):
        normalSum = 0
        weightsSum = 0
        for _ in range(len(A)):
            normalSum += A[_][i]
            weightsSum += (_ + 1) * A[_][i]
        if normalSum == 0:
            BilC[i] = -1.0
        else:
            BilC[i] = weightsSum / normalSum

    KMi = 0
    for i in range(0, len(A) - 1):
        for j in range(i + 1, len(A)):
            for m in range(0, len(A[0]) - 1):
                for n in range(m + 1, len(A[0])):
                    KMi += A[i][n] * A[j][m]
    return KMi, BikR, BilC


def MartrixGenerate(N, lvl, edges, originalData):
    M = []
    for i in range(len(lvl) - 1):
        M.append([[0.0 for _ in range(len(lvl[i + 1]))] for _ in range(len(lvl[i]))])

    # as for the sequence for the initial matrix, we just use the lvl
    for m, n in enumerate(lvl):
        if m == len(lvl) - 1:
            break
        # the m-th matrix in matrices
        for i, t in enumerate(n):
            # i is the row number
            # t is the name of node
            for k in N[t]["out"]:
                # k is the name of node in "out"
                # if k in lvl[m+1]:
                j = lvl[m + 1].index(k)

                # the virtual node share the width with the original link
                # if we meet the virtual node, we just need to search for
                # the original link and use its width
                # however, it doesn't affect the position in the matrix
                if len(t.split("->")) > 1:
                    linkOrder = edges.index((t.split("->")[1], t.split("->")[2]))
                elif len(k.split("->")) > 1:
                    linkOrder = edges.index((k.split("->")[1], k.split("->")[2]))
                else:
                    linkOrder = edges.index((t, k))
                # M[m][i][j] = float(originalData[linkOrder]["value"])
                M[m][i][j] = 1
    return M


def Phase1(N, lvl, edges, originalData):
    # KM = [0 for _ in range(len(lvl) - 1)]
    # BR = [0 for _ in range(len(lvl) - 1)]
    # BC = [0 for _ in range(len(lvl) - 1)]
    M = MartrixGenerate(N, lvl, edges, originalData)
    i = 0
    while i < len(lvl) - 1:
        # PD sub-algorithm, process BilC
        temp = {}
        KM, BR, BC = barycenterMatrixCalc(M[i])
        for t in range(len(BC)):
            temp[lvl[i + 1][t]] = BC[t]
        temp = sorted(temp.items(), key=lambda x: x[1])
        for t in range(len(temp)):
            lvl[i + 1][t] = temp[t][0]

        M = MartrixGenerate(N, lvl, edges, originalData)
        i += 1

    while i > 0:
        # PU sub-algorithm, process BilC
        temp = {}
        KM, BR, BC = barycenterMatrixCalc(M[i - 1])
        for t in range(len(BR)):
            temp[lvl[i - 1][t]] = BR[t]
        temp = sorted(temp.items(), key=lambda x: x[1])
        for t in range(len(temp)):
            lvl[i - 1][t] = temp[t][0]

        M = MartrixGenerate(N, lvl, edges, originalData)
        i -= 1
    return M


def Phase2D(N, lvl, edges, originalData):
    KM = [[] for _ in range(len(lvl) - 1)]
    BR = [[] for _ in range(len(lvl) - 1)]
    BC = [[] for _ in range(len(lvl) - 1)]
    M = MartrixGenerate(N, lvl, edges, originalData)
    i = 0

    while i < len(lvl) - 1:
        # PD sub-algorithm, process BilC
        KM[i], BR[i], BC[i] = barycenterMatrixCalc(M[i])
        i += 1

    for i in range(len(BC)):
        temp = {}
        for t in range(len(BC[i])):
            temp[lvl[i + 1][t]] = BC[i][t]

        temp = list(temp.items())

        # we have finished the data acquirement
        # next, we start to search the same values in nodes and reverse them
        t = 0
        while t < len(temp) - 1:
            temp2 = []
            if temp[t][1] == temp[t + 1][1]:
                temp2.append(temp[t])
                # find the same value
                for j in range(t + 1, len(temp)):
                    if temp[t][1] == temp[j][1]:
                        temp2.append(temp[j])
                    else:
                        break
                for j in range(t, t + len(temp2)):
                    temp[j] = temp2[t + len(temp2) - j - 1]
                t = t + len(temp2)
            else:
                t = t + 1

        for t in range(len(temp)):
            lvl[i + 1][t] = temp[t][0]


def Phase2U(N, lvl, edges, originalData):
    KM = [[] for _ in range(len(lvl) - 1)]
    BR = [[] for _ in range(len(lvl) - 1)]
    BC = [[] for _ in range(len(lvl) - 1)]
    M = MartrixGenerate(N, lvl, edges, originalData)
    i = len(lvl) - 1

    while i > 0:
        # PU sub-algorithm, process BikR
        KM[i - 1], BR[i - 1], BC[i - 1] = barycenterMatrixCalc(M[i - 1])
        i -= 1

    for i in range(len(BR)):
        temp = {}
        for t in range(len(BR[i])):
            temp[lvl[i][t]] = BR[i][t]

        temp = list(temp.items())

        # we have finished the data acquirement
        # next, we start to search the same values in nodes and reverse them
        t = 0
        while t < len(temp) - 1:
            temp2 = []
            if temp[t][1] == temp[t + 1][1]:
                temp2.append(temp[t])
                # find the same value
                for j in range(t + 1, len(temp)):
                    if temp[t][1] == temp[j][1]:
                        temp2.append(temp[j])
                    else:
                        break
                for j in range(t, t + len(temp2)):
                    temp[j] = temp2[t + len(temp2) - j - 1]
                t = t + len(temp2)
            else:
                t = t + 1

        for t in range(len(temp)):
            lvl[i][t] = temp[t][0]


def graphCrossMin(G_inv, Levels, edges, originalData):
    """
    to generate the final graph result by barycenter
    :param G_inv: original graph
    :param Levels: original nodes level info
    :param edges: original edges list info
    :param originalData: real originalData which used for generating matrix
    :return: Final Graph Info N and Final Level Info lvl
    """

    lvl = copy.deepcopy(Levels)
    N = copy.deepcopy(G_inv)

    # construct the matrices
    # notice: the matrix is combined with rows Vk-th and columns Vk+1-th

    while True:
        M0 = Phase1(N, lvl, edges, originalData)
        M1 = Phase1(N, lvl, edges, originalData)
        if M0 == M1:
            break

    Phase2D(N, lvl, edges, originalData)

    while True:
        M0 = Phase1(N, lvl, edges, originalData)
        M1 = Phase1(N, lvl, edges, originalData)
        if M0 == M1:
            break

    Phase2U(N, lvl, edges, originalData)

    while True:
        M0 = Phase1(N, lvl, edges, originalData)
        M1 = Phase1(N, lvl, edges, originalData)
        if M0 == M1:
            break

    return N, lvl


if __name__ == '__main__':
    # 当前edges的顺序与originalData["links"]中的排列顺序完全一致
    # 故需要用到value时直接提取即可<-edge.index((a, b))

    z = open("output.txt", "w")
    for Z in range(15):
        with open("./dataset/RandomDataset/auto-generating-data" + str(Z) + ".json") as f:

        # with open("./dataset/RandomDataset/test-auto-generating-data.json", mode="r") as f:

        # with open("./dataset/RealWorldDataset/dataFromlisachristina1234ongithub.json", mode="r") as f:
        # with open("./dataset/RealWorldDataset/nottest.json", mode="r") as f:
        # with open("./dataset/test-data0.json", mode="r") as f:
        # with open("./dataset/RealWorldDataset/Energy flows in UK (2050).json", mode="r") as f:
        # with open("dataset/RealWorldDataset/rCharts Examples Sankey Particles.json", mode="r") as f:
        # with open("./dataset/RealWorldDataset/medals.json", mode="r") as f:
        # with open("./dataset/RealWorldDataset/product_2.json", mode="r") as f:
        # with open("./dataset/RealWorldDataset/us-energy-consumption.json", mode="r") as f:
        # with open("./dataset/RealWorldDataset/holiday_data.json", mode="r") as f:
        # with open("./dataset/RealWorldDataset/City of Oakland Budget Sankey Particles.json", mode="r") as f:
            originalData = json.load(f)
        edges = []
        for i in originalData.get("links"):
            edges.append((str(i["source"]), str(i["target"])))

        G = graphFromEdges(edges)  # 完成对原始边集的访问并生成以顶点为键，以出入边为键值的字典对象为值的新字典：N
        S = cycleAnalysis(G)  # 消除环图
        # printGraph(G)  # 打印G

        G_inv = invertBackEdges(G, S)  # inverted edges are only for level assignment
        L = levelAssignment(G_inv)  # figure out the level and the nodes on the level, L contains the level info
        print(L)

        # search for the best situation which the most important part
        G_inv, L_b = getInBetweenNodes(G_inv, L)  # add virtual nodes to prevent links crossing levels
        print(L_b)

        z.write(
            "--------------------------------\n"
            "fileName: auto-generating-data" + str(Z) + "\n\n" +
            "L_b = " + json.dumps(L_b) + "\n\n"
        )

        G_fin, L_fin = graphCrossMin(G_inv, L_b, edges, originalData.get("links"))
        # printGraph(G_inv)
        # print(G_fin)
        # print(L_fin) zimpl
        print()
        print("---------------------------")
        print()

        print(G_fin)

        print()
        print("---------------------------")
        print()

        links_html = []
        level_html = [[] for _ in range(len(L_fin))]

        for i in range(len(L_fin)):
            size = 0
            if i == len(L_fin) - 1:
                for t in L_fin[i]:
                    size = 0
                    for m in originalData["links"]:
                        if str(m['target']) == t:
                            size += float(m['value'])
                    level_html[i].append({"name": t, "size": size})
            else:
                for t in L_fin[i]:
                    size = 0
                    if len(t.split('->')) == 1:
                        for m in originalData["links"]:
                            if str(m['source']) == t:
                                size += float(m['value'])
                    else:
                        for m in originalData["links"]:
                            if t.split('->')[1] == str(m['source']) and t.split("->")[2] == str(m['target']):
                                size = float(m["value"])
                    level_html[i].append({"name": t, "size": size})

        # generate the "links" list which we need for html file
        # in this part, we only analyze the "out" part in G_fin
        # and when we meet the dummy node, we just need to
        # search for the original link
        # we use the combination of part[2] for source name
        # and part[3] for target name in dummy node name
        # such as "dummy->Livestock and Manure->Methane->V2"
        # will be changed into Livestock and Manure, Methane
        for i in list(G_fin.keys()):
            splitResult = i.split('->')
            if len(splitResult) == 1:
                # the 'source node' is regular node, not dummy
                for t in G_fin[i]['out']:
                    temp = t.split("->")
                    if len(temp) == 1:
                        # the 'target node' is also regular node
                        for m in originalData['links']:
                            if str(m['source']) == i and str(m['target']) == t:
                                links_html.append({'source': i, 'target': t, 'value': str(m['value'])})
                    else:
                        # attention! 'target node' is dummy node
                        for m in originalData['links']:
                            if str(m['source']) == i and str(m['target']) == temp[2]:
                                links_html.append({'source': i, 'target': t, 'value': str(m['value'])})

            else:
                # it's dummy node and there is only one link in its 'out' list
                for t in G_fin[i]['out']:
                    for m in originalData['links']:
                        if str(m['source']) == splitResult[1] and str(m['target']) == splitResult[2]:
                            links_html.append({'source': i, 'target': t, 'value': str(m['value'])})

        finalResult = [[t for t in range(1, len(level_html[i]) + 1)] for i in range(len(level_html))]

        z.write(
            "let links = " + json.dumps(links_html) + "\n\n" +
            "let level = " + json.dumps(level_html) + "\n\n" +
            "let result = " + json.dumps(finalResult) + "\n\n\n"
        )

    z.close()
