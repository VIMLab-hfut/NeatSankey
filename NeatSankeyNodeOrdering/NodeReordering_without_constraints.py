import copy
import math

def removeNode(N, n):  # remove the node: n, in N
    if N.get(n) is None:
        return

    for p in N[n]['in']:  # for parent (remove all that have this as child)
        N[p]['out'].remove(n)

    for c in N[n]['out']:  # for child (remove all that have this as parent)
        N[c]['in'].remove(n)

    del N[n]  # dictionary remove


def removeEdges(N, E):  # remove the edge: E
    for s, d in E:
        if d in N[s]['out']:
            N[s]['out'].remove(d)  # 从出点s的out列表里删除了对入点d的指向

        if s in N[d]['in']:
            N[d]['in'].remove(s)  # 同理


def insertEdges(N, E):
    for s, d in E:
        if d not in N[s]['out']:
            N[s]['out'].append(d)

        if s not in N[d]['in']:
            N[d]['in'].append(s)


def twistEdges(N, E):
    removeEdges(N, E)
    E_inv = [(d, s) for s, d in E]
    insertEdges(N, E_inv)

    return E_inv


def graphFromEdges(E):
    N = {}
    # node: in = [] out = []
    for e in E:
        s, d = e

        if N.get(s) is None:
            N[s] = {'in': [], 'out': []}

        if N.get(d) is None:
            N[d] = {'in': [], 'out': []}

        N[s]['out'].append(d)  # out
        N[d]['in'].append(s)  # in
    return N


def printGraph(N):
    for n in N:  # n只包含键值
        print(str(n))
        for e in N[n]:  # 深入访问属性
            print('{}: {}'.format(e, N[n][e]))


# if __name__ == '__main__':
#     edges = [('A', 'B'), ('A', 'E'), ('B', 'C'), ('C', 'D'), ('D', 'C'), ('A', 'C')]
#     printGraph(graphFromEdges(edges))


# 1. Eliminate cycles
# 2. Assign nodes to levels
# 3. Minimize edge crosses
# 4. Assign nodes to cartesian coordinates
# 5. Restore original cycles

# 1. Eliminate cycles, build succession with minimal count of backedge.
#   (a) Save sources and sinks in two different lists
#   (b) Remove source nodes successively and add to source list
#   (c) remove sink nodes successively and add to sink list
#   (d) chose next candidate according to in- and out-rank of node, rangOut = maxNode( [R_out(v) - R_in(v) for v in G] )
#   (e) remove v from Graph and add to source list
def cycleAnalysis(G):
    N = copy.deepcopy(G)  # graph will be altered... copy graph
    # printGraph(N)

    Sl, Sr = [], []  # Sl, Sr in Sugiyama et. al.

    while N:  # while N not empty
        sources = [n for n in N if len(N[n]['in']) == 0]  # with the attribute 'in' === 0, this must be an source node
        sinks = [n for n in N if len(N[n]['out']) == 0]  # with the attribute 'out' === 0, this must be an target node

        # this is a dynamical progress
        # we only process one node once, because no matter what we have done,
        # the effects will affect the nodes set: N immediately, and we should reconsider about that
        # (b)
        if sources:
            Sl += sources
            for n in sources:
                removeNode(N, n)  # remove all sinks

        # (c)
        elif sinks:
            Sr += sinks
            for n in sinks:
                removeNode(N, n)  # remove all sinks

        # (d)
        elif N:
            o = max(N, key=lambda n: len(N[n]['out']) - len(N[n]['in']))  # get node with maximum rangOut
            # (e)
            Sl += [o]
            removeNode(N, o)

    return Sl + Sr


# invert cyclic edge
def invertBackEdges(G, S):
    # use the sequence S that generated by cycleAnalysis to
    N = copy.deepcopy(G)  # graph will be altered... copy graph
    B = []  # backedges
    for i, n in enumerate(S):
        # enumerate() 函数可将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标
        # now i is the index and n is the data

        C = N[n]['out']  # children
        for c in C:
            j = S.index(c)
            if j < i:
                B += [(n, c)]

    twistEdges(N, B)

    return N


# 2. Assign each node to horizontal Level
#   (a) Determine sinks
#   (b) Assign them to new level
#   (c) Delete all sinks from graph

# takes acyclic Graph
def levelAssignment(G):
    N = copy.deepcopy(G)

    L = []  # levels

    while N:  # while N not empty
        # (a)
        sources = [n for n in N if len(N[n]['in']) == 0]

        # (c)
        L += [sources]  # L = []; L += [ ['A', 'B', 'C'] ] =>  L = [ ['A', 'B', 'C'] ]

        # (b)
        for n in sources:
            removeNode(N, n)

    return L  # [x for x in reversed(L)]  # reversed: reverse a sequence


# take (a, b) and if there lies a level between them (which they are not connected over):
#   - take a as from node,
#   - create a new node
#   - connect that new node to a
#   - connect that new node to b
#   - for multiple levels in between
def solveMidTransition(N, edge, L):
    (a, b) = edge

    # return the levels that lie between the node

    lfrom = N[a]['level']
    lto = N[b]['level']

    if lto < lfrom:
        step = -1
    else:
        step = 1

    removeEdges(N, [(a, b)])  # remove original edge

    u = a  # (u, v)
    for i in range(lfrom + step, lto, step):  # for levels between a and b
        # v = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(3))
        v = str("dummy" + "->" + str(a) + "->" + str(b) + "->V" + str(i))

        N[u]['out'] += [v]
        N[v] = {'in': [u], 'out': [], 'level': i, 'between': True}
        L[i] += [v]  # add to level
        u = v

    N[u]['out'] += [b]  # u is last created node... connect that one to b
    N[b]['in'] += [u]  # u is last created node... connect that one to b

    return N, L


def getInBetweenNodes(G, L):
    N = copy.deepcopy(G)

    for i, l in enumerate(L):
        for j in l:
            N[j]['level'] = i  # assign each node a level

    IB = []

    # n: current source node
    # nLevel: the rank or current source node
    # c: current target node which lies in "out" list of current source node
    # cLevel: the rank of current target node
    # when fabs(cLevel-nLevel) > 0, it means this link covers more than two ranks
    for nLevel, l in enumerate(L):
        for n in l:
            node = N[n]
            for c in node['out']:
                cLevel = N[c]['level']

                dif = math.fabs(cLevel - nLevel)  # if more than two level between
                if dif > 1:
                    IB += [(n, c)]

    for (n, c) in IB:
        solveMidTransition(N, (n, c), L)

    return N, L

def findViolatedConstraint(constrainedVertices, constraints, vertexInfo):

    activeVertices = set()
    indeg = dict()
    incomingConstraints = dict()

    for f, t in constraints:
        indeg[t] = indeg.get(t, 0) + 1

    for v in constrainedVertices:
        incomingConstraints[v] = []
        if indeg.get(v, 0) == 0:
            activeVertices.add(v)

    while activeVertices:
        v = activeVertices.pop()
        for c in incomingConstraints[v]:
            if vertexInfo[c[0]]["bv"] > vertexInfo[c[1]]["bv"]:
                return True, c
        # print(constraints)
        for c in [x for x in constraints if x[0] == v]:
            t = c[1]
            incomingConstraints[t].append(c)
            if len(incomingConstraints[t]) == indeg[t]:
                activeVertices.add(t)

    return False, None

# 需要修改的函数
def barycenterDirectlyCalc(layerList, G, constraints = []):
    """
    Calcualate the barycenter each line and row
    计算重心，并按照重心进行排序
    :param layerList: the node info with its order in two nearby layer
        layerList example: [[layer1], [layer2]]
        layer1: [node1Name: ,node2Name: ,...]
    :param edges: the edges info in total graph, we will do the slicing later

    :return: new node list with extra attributes: b(v)
    """

    vertexInfo = dict()
    constrainedVertices = set()
    for item in constraints:
        constrainedVertices.add(item[0])
        constrainedVertices.add(item[1])
    unconstrainedVertices = set(layerList[1]) - constrainedVertices

    for secondLayerNode in layerList[1]:
        currentNodeDict = {"bv": 0, "deg": 0, "list":[secondLayerNode]}  # 存储节点、重心和入度
        # 计算重心
        for firstLayerNode in G[secondLayerNode]['in']:
            currentNodeDict["bv"] += layerList[0].index(firstLayerNode) + 1
            currentNodeDict["deg"] += 1
        currentNodeDict["bv"] /= currentNodeDict["deg"]

        vertexInfo[secondLayerNode] = currentNodeDict
    tempNum = 1
    while True:
        loop, con = findViolatedConstraint(constrainedVertices, constraints, vertexInfo)
        if not loop:
            break

        s, t = con[0], con[1]
        print(s,t)
        tempName = "temp" + str(tempNum)
        tempNum += 1

        currentNodeDict = {"bv": 0, "deg": 0, "list": []}
        currentNodeDict["deg"] = vertexInfo[s]["deg"] + vertexInfo[t]["deg"]
        currentNodeDict["bv"] = (vertexInfo[s]["deg"] * vertexInfo[s]["bv"]
                                 + vertexInfo[t]["deg"] * vertexInfo[t]["bv"]) / currentNodeDict["deg"]
        currentNodeDict["list"] = vertexInfo[s]["list"] + vertexInfo[t]["list"]
        vertexInfo[tempName] = currentNodeDict

        for c in constraints:
            if c[0] == s or c[0] == t:
                c[0] = tempName
            if c[1] == s or c[1] == t:
                c[1] = tempName

        constraints.remove([tempName, tempName])
        constrainedVertices.remove(s)
        constrainedVertices.remove(t)

        if tempName in [v for item in constraints for v in item]:
            constrainedVertices.add(tempName)
        else:
            unconstrainedVertices.add(tempName)

    allVertices = list(constrainedVertices | unconstrainedVertices)
    allVertices.sort(key = lambda name: vertexInfo[name]["bv"])
    # print("allVertices:")
    # print(allVertices)
    # print()
    concatenateVertices = list()
    for v in allVertices:
        concatenateVertices.extend(vertexInfo[v]["list"])

    for k, item in vertexInfo.items():
        print("Name : "+k)
        for key, val in item.items():
            print(key+":", end='')
            print(val)
        print()

    # 按照重心进行排序的结果 [sourceNode['name'] for sourceNode in sorted(newLayerList, key=lambda newLayerList: newLayerList['bv'])]
    return concatenateVertices


def generateAllPermutationsForFirstLayer(layer1, startPos, endPos, generateResult):
    if startPos == endPos:
        generateResult.append([node for node in layer1])
    for index in range(startPos, endPos):
        layer1[index], layer1[startPos] = layer1[startPos], layer1[index]
        generateAllPermutationsForFirstLayer(layer1, startPos + 1, endPos, generateResult)
        layer1[startPos], layer1[index] = layer1[index], layer1[startPos]
    return


def MartrixGenerate(N, lvl, edges, originalData):
    M = []
    for i in range(len(lvl) - 1):
        M.append([[0.0 for _ in range(len(lvl[i + 1]))] for _ in range(len(lvl[i]))])

    # as for the sequence for the initial matrix, we just use the lvl
    for m, n in enumerate(lvl):
        if m == len(lvl) - 1:
            break
        # the m-th matrix in matrices
        for i, t in enumerate(n):
            # i is the row number
            # t is the name of node
            for k in N[t]["out"]:
                # k is the name of node in "out"
                # if k in lvl[m+1]:
                j = lvl[m + 1].index(k)

                # the virtual node share the width with the original link
                # if we meet the virtual node, we just need to search for
                # the original link and use its width
                # however, it doesn't affect the position in the matrix
                if len(t.split("->")) > 1:
                    linkOrder = edges.index((t.split("->")[1], t.split("->")[2]))
                elif len(k.split("->")) > 1:
                    linkOrder = edges.index((k.split("->")[1], k.split("->")[2]))
                else:
                    linkOrder = edges.index((t, k))
                M[m][i][j] = float(originalData[linkOrder]["value"])
    return M


def crossingDetecting(Graph, singlelayerMatrix, l1, l2):
    pairsWithLayer2Nodes = {i: [] for i in l2}

    for firstLayerNode in l1:
        # after the cycle, we can fink all the edges link
        for edgeToSinks in Graph[firstLayerNode]["out"]:
            pairsWithLayer2Nodes[edgeToSinks].append(l1.index(firstLayerNode))

    # we start a cycle based on order in l2
    # we do the cycling from the top vertex in l2 to the current vertex
    # to detect the reverse pairs, which mean crossings

    crossingPairRecorder = []
    for i in range(len(l2)):
        # pointer i points to the node that we are detecting in order
        for t in range(0, i + 1):
            # pointer t points to the node that used for comparing from top to current node
            for m in pairsWithLayer2Nodes[l2[i]]:
                #
                for n in pairsWithLayer2Nodes[l2[t]]:
                    if n > m:
                        # we find a crossing, add this two edge into recorder
                        crossingPairRecorder.append(
                            {"source1": n, "target1": t, "source2": m, "target2": i}
                        )

    ValueSum = 0
    for i in crossingPairRecorder:
        Wi = singlelayerMatrix[i['source1']][i['target1']]
        Wj = singlelayerMatrix[i['source2']][i['target2']]

        if Wi - Wj == 0:
            pass
        else:
            ValueSum += 1 / (Wi - Wj) if Wi - Wj > 0 else Wj - Wi

    return ValueSum


def evaluating(Graph, layerMatrix, lvl):
    """
    to evaluate current permutation is good or not in our standard
    :param Graph: G_inv, N,
    :param layerMatrix: Matrix generated by "MartrixGenerate" function
    :param lvl: current all nodes permutation info
    :return: scores of this permutation, the smaller the better
    """
    currentPermutationValueSum = 0
    for _ in range(len(layerMatrix)):
        currentPermutationValueSum += crossingDetecting(Graph, layerMatrix[_], lvl[_], lvl[_ + 1])

    return currentPermutationValueSum

def objFunc(layerList, edges, originalDataCopy):
    value = 0
    layerLength1 = len(layerList[0])
    layerLength2 = len(layerList[1])

    edgesCopy = dict()
    for edge in edges:
        if edge[0] in layerList[0] and edge[1] in layerList[1]:
            for item in originalDataCopy:
                if item['source'] == edge[0] and item['target'] == edge[1]:
                    edgesCopy[edge] = item['value']

    for i in range(layerLength1):
        for j in range(i+1, layerLength1):
            for p in range(layerLength2):
                for q in range(p+1, layerLength2):
                    node1 = layerList[0][i]
                    node2 = layerList[0][j]
                    node3 = layerList[1][p]
                    node4 = layerList[1][q]
                    wi = edgesCopy.get((node1, node4), 0)
                    wj = edgesCopy.get((node2, node3), 0)
                    if wi != 0 and wj != 0:
                        value += 1 / math.fabs(wi - wj)

    return value

def generateConstraints(layerList, edges, N, originalDataCopy):
    constraints = []
    vertexInfo = dict()
    layerLength = len(layerList[1])

    for i in range(layerLength):
        node1 = layerList[1][i]
        changeMax = 0
        ans = (node1, node1)
        for j in range(i+1, layerLength):
            node2 = layerList[1][j]
            val = objFunc([layerList[0], ], edges, originalDataCopy)
            if val > changeMax:
                ans = (node1, node2)
                changeMax = val



        vertexInfo[secondLayerNode] = currentNodeDict
    return constraints

def graphCrossMin(G_inv, Levels, edges, originalData):
    """
    to generate the final graph result by barycenter
    :param G_inv: original graph
    :param Levels: original nodes level info
    :param edges: original edges list info
    :param originalData: real originalData which contains the "size(width)" info of every line
    :return: Final Graph Info N and Final Level Info lvl
    """

    # 防止原始G_inv等数据被破坏，使用深拷贝来复制相关参数
    lvl = copy.deepcopy(Levels)
    N = copy.deepcopy(G_inv)
    edgesCopy = copy.deepcopy(edges)
    originalDataCopy = copy.deepcopy(originalData)

    # construct the matrices
    # notice: the matrix is combined with rows Vk-th and columns Vk+1-th

    # 构造第一层的全排列，并尝试第一层的每一种可能性
    layer1Choices = []
    generateAllPermutationsForFirstLayer(lvl[0], 0, len(lvl[0]), layer1Choices)
    # because we use an arbitrary as the first layer which is never gotten changed in next cycle
    # in that case, we should generate all the possible permutations and find the best one

    bestPermutation = []
    minimalValue = -1

    # 对于第一层全排列的其中一个全排列
    for layer1List in layer1Choices:
        currentLayersList = [layer1List]
        # 两层两层进行
        for i in range(len(lvl) - 1):
            # generateConstraints([lvl[i], lvl[i + 1]], edges, N, originalDataCopy)
            currentLayersList.append(barycenterDirectlyCalc([lvl[i], lvl[i + 1]], N, constraints=[]))
            # after the iteration, we get the barycenter value of every nodes and sort them in order
            # we give another permutation for the first line and restart the cycle until all the possible
            # permutations were tested and at last we will only choose the best one

        # print(currentLayersList)

        # 评价目标函数
        currentNodePermutationValue = evaluating(N, MartrixGenerate(N, currentLayersList, edgesCopy, originalDataCopy),
                                                 currentLayersList)

        if minimalValue == -1:
            minimalValue = currentNodePermutationValue
            bestPermutation = currentLayersList
        elif minimalValue > currentNodePermutationValue:
            minimalValue = currentNodePermutationValue
            bestPermutation = currentLayersList

    # print("bestPermutation")
    # print(bestPermutation)
    # print("minimalValue")
    # print(minimalValue)
    return N, bestPermutation
